{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p> Bitcoindevkit AndroidDemo Wallet <p> </p> <p>The Android Bitcoindevkit Demo Wallet (we're calling it the Devkit Wallet for short) is a simple testnet Bitcoin wallet built as a reference app for the bitcoindevkit on Android. It is purposely lean on Android-specific bells and whistles in order to keep the focus on bitcoin fundamentals and the bitcoindevkit API.</p> <p>The repository is built to help newcomers to the bitcoindevkit by layering complexity slowly while not bloating the codebase with too much UI polish.</p> <p>The repository works in the following way: multiple app are maintained in parallel, each of them focusing on showcasing different levels of integration between the bitcoin development kit and the applications.  </p> <ol> <li>The ui-only app showcases the basic design and UI without any functionality.</li> <li>The simple-wallet app showcases a simple bitcoin wallet which implements the core functionality one would expect from a wallet: create addresses, send, receive, display transaction history, and wallet recovery.</li> <li>The advanced-features app showcases some of the more advanced features of the bitcoin development kit library, like sending to multiple recipients, replace-by-fee (BIP125), custom Electrum server, and creating OP_RETURN outputs.</li> <li>The kpm apps showcase how to build Android and iOS apps using the same codebase and sharing common code for bitcoin-related logic while writing the user interface in the native languages (Kotlin for Android and Swift for iOS).</li> </ol> <p>Each of those apps has a documentation page associated with it, accessible with the navbar above.</p> <p></p>"},{"location":"advanced-features/","title":"Advanced Features App","text":"<p>This page is currently under development. If you'd like to contribute, let me know on the repo!</p> <p></p> <p>The Advanced Features App builds on the Simple Wallet and adds the following features:</p> <ul> <li>Send to multiple recipients</li> <li>\"Send All\" functionality</li> <li>Replace-by-Fee (BIP125)</li> <li>Choose custom Electrum server</li> <li>Create OP_RETURN outputs</li> </ul>"},{"location":"kmp/","title":"Kotlin Multiplatform Apps","text":"<p>This page is currently under development. If you'd like to contribute, let me know on the repo!</p>"},{"location":"simple-wallet/","title":"Building a Simple Testnet Wallet","text":"<p>This page is the second part of a walkthrough tutorial of the DevKit Wallet codebase.</p> <p>Note that this page concerns itself with the <code>simple-wallet</code> branch of the repository.</p> <p>We break the journey of building the wallet into 6 distinct steps: 1. Create a Wallet object with the Repository design pattern 2. Implement receive and sync functionalities 3. Implement send functionality 4. Query and display transaction history 5. Display recovery phrase 6. Implement wallet recovery from BIP39 words</p>"},{"location":"simple-wallet/#task-1-add-wallet-and-repository-objects","title":"Task 1: Add Wallet and Repository objects","text":"<p>This is where things get interesting on the bitcoin side of things. This task introduces 2 new objects: the <code>Wallet</code> object and the <code>Repository</code> object.</p> <p>Both are initialized on startup by the <code>DevkitWalletApplication</code> class, with some properties they need to function (wallet path and shared preferences respectively).</p>"},{"location":"simple-wallet/#wallet-object","title":"Wallet object","text":"<p>The <code>Wallet</code> class is our window to the bitcoindevkit. It's the only class that interacts with the bitcoindevkit directly and you'll find in there most of the API. Methods like <code>createWallet()</code>, <code>loadExistingWallet()</code>, and <code>recoverWallet()</code> allow you to generate/recover wallets on startup, and methods like <code>sync()</code>, <code>getNewAddress()</code>, and <code>getBalance()</code> provide the necessary interactions one would expect from a bitcoin wallet library.</p>"},{"location":"simple-wallet/#repository-object","title":"Repository object","text":"<p>The Repository design pattern is common in Android applications. The idea is to create a layer of separation between the UI (activities, fragments) and the data they need to function. A <code>Repository</code> class is often used as the bridge between the two. For example, a composable might need to display a list of friends the user has, and that list might be available from different locations (say a ping to a microservice, or a lookup in a local cache). It's important to pull that sort of decision/code away from UI components. This is typically the sort of thing that the repository will do; make decisions as to where and how to get data for the UI fragments that request it.</p> <p>For us this shows up when the <code>DevkitWalletActivity</code> tries to decide if the user already has a wallet initialized upon launch. In this case the activity simply asks the <code>Repository</code> the question <pre><code>Repository.doesWalletExist()\n</code></pre> and doesn't care how the Repository knows (in this example the repository uses a boolean value stored in shared preferences). Shared preferences are a way to store small amounts of data quickly without requiring a database. Common use cases are small strings and booleans (like choice of color theme, whether something has been completed, etc.).</p>"},{"location":"simple-wallet/#using-the-bitcoindevkit","title":"Using the bitcoindevkit","text":"<p>We can see the library in action through the logs, for example when creating a new wallet, generating new addresses, and syncing. Log statements are scattered through the app and look like this: <pre><code>Log.i(TAG, \"Loading existing wallet, descriptor is ${initialWalletData.descriptor}\")\n</code></pre> </p>"},{"location":"simple-wallet/#task-2-implement-receive-and-sync","title":"Task 2: Implement receive and sync","text":"<p>It's now time to connect the <code>Wallet</code> object to the user interface. Note how the \"generate new address\" button has an on <code>onClick</code> parameter that triggers the <code>updateAddress()</code> method on the viewmodel: <pre><code>// ReceiveScreen.kt\nButton(\nonClick = { addressViewModel.updateAddress() },\ncolors = ButtonDefaults.buttonColors(DevkitWalletColors.auroraGreen),\nshape = RoundedCornerShape(16.dp),\n) {\nText(\ntext = \"generate new address\",\nfontSize = 14.sp,\n)\n}\n</code></pre></p> <p>This viewmodel in turns calls the <code>Wallet.getLastUnusedAddress()</code>, which itself is a simple call to the bitcoin dev kit wallet object: <pre><code>// Wallet.kt\nobject Wallet {\n// ...\nfun getLastUnusedAddress(): String = wallet.getLastUnusedAddress()\n}\n</code></pre></p>"},{"location":"simple-wallet/#qr-codes","title":"QR codes","text":"<p>QR codes are generated using a library called zxing (you'll find the dependency in the <code>/app/build.gradle.kts</code> file).</p>"},{"location":"simple-wallet/#sync","title":"Sync","text":"<p>The sync functionality in Devkit Wallet is very simple (<code>Wallet.sync()</code> will do). The sync is a call to the blockstream testnet public Electrum server. But note that we also wish to update the UI to reflect the current balance upon sync, and this is done using something called the viewmodel, a very common pattern in Android applications. ViewModels are a way to implement the observer pattern.</p> <p>Take a look at the <code>WalletViewModel</code> class: <pre><code>class WalletViewModel() : ViewModel() {\nprivate var _balance: MutableLiveData&lt;ULong&gt; = MutableLiveData(0u)\nval balance: LiveData&lt;ULong&gt;\nget() = _balance\nfun updateBalance() {\nWallet.sync()\n_balance.value = Wallet.getBalance()\n}\n}\n</code></pre></p> <p>Fragment and activities can simply \"observe\" (subscribe to) particular variables in our ViewModel, and the ViewModel will update them as this value changes. This ensures that the balance displayed in the composable is always up to date with the balance in the <code>WalletViewModel</code>. Easy peasy bitcoineesy.</p> <p> </p>"},{"location":"simple-wallet/#task-3-implement-send","title":"Task 3: Implement send","text":"<p>Sending bitcoin is a slightly more involved operation.</p> <p>The bitcoindevkit workflow for this operation is as follows: 1. Create a transaction (you'll need amount, fee rate, and a recipient's address) 2. Sign the transaction 4. Broadcast it</p> <p>Note that all 3 of those steps are accomplished by the <code>broadcastTransaction()</code> method of the <code>SendScreen</code>: <pre><code>private fun broadcastTransaction(recipientAddress: String, amount: ULong, feeRate: Float = 1F) {\ntry {\n// create, sign, and broadcast\nval psbt: PartiallySignedBitcoinTransaction = Wallet.createTransaction(recipientAddress, amount, feeRate)\nWallet.sign(psbt)\nval txid: String = Wallet.broadcast(psbt)\nLog.i(TAG, \"Transaction was broadcast! txid: $txid\")\n} catch (e: Throwable) {\nLog.i(TAG, \"Broadcast error: ${e.message}\")\n}\n}\n</code></pre></p> <p>The required bitcoindevkit library calls inside the <code>Wallet</code> object are fairly simple: <pre><code>    fun createTransaction(recipient: String, amount: ULong, fee_rate: Float?): PartiallySignedBitcoinTransaction {\nreturn PartiallySignedBitcoinTransaction(wallet, recipient, amount, fee_rate)\n}\nfun sign(psbt: PartiallySignedBitcoinTransaction): Unit {\nwallet.sign(psbt)\n}\nfun broadcast(signedPsbt: PartiallySignedBitcoinTransaction): String {\nreturn wallet.broadcast(signedPsbt)\n}\n</code></pre> </p>"},{"location":"simple-wallet/#task-4-add-transaction-history","title":"Task 4: Add transaction history","text":"<p>Adding a list of transactions to a wallet is a daunting task if one is to take it to a polished result. It involves using a database and keeping track of transactions, their state, and performing calculations on the raw material that the bitcoindevkit provides, and is slightly outside of the scope of this sample wallet. Simply displaying the list of transactions as one long string (with some small modifications), however, is quite easy, and this is what this wallet implements.</p> <p>Note that the list of transactions is simply a string built by the <code>confirmedTransactionsList()</code> method and displayed in a <code>Text()</code> composable (same is true for pending transactions).</p> <p>Creating the timestamp is the most involved part of this whole endeavour, and is done using a neat Kotlin feature called extension functions, where we define a method on the <code>ULong</code> type which returns a nicely formatted timestamp. Take a look at the <code>utilities/Timestamps.kt</code> file for more on this function. Building the string is otherwise a rather simple affair; the bitcoindevkit returns an object of type <code>List&lt;Transaction&gt;</code> through the <code>getTransactions()</code> method, and we iterate over them and pull the interesting components into a string template.</p> <pre><code>// TransactionsScreen.kt\n// ...\nText(\ntext = confirmedTransactionsList(allTransactions.filterIsInstance&lt;Transaction.Confirmed&gt;()),\nfontSize = 12.sp,\nfontFamily = firaMono,\ncolor = DevkitWalletColors.snow1\n)\n// ...\nprivate fun confirmedTransactionsList(transactions: List&lt;Transaction.Confirmed&gt;): String {\nif (transactions.isEmpty()) {\nLog.i(TAG, \"Confirmed transaction list is empty\")\nreturn \"No confirmed transactions\"\n} else {\nval sortedTransactions = transactions.sortedByDescending { it.confirmation.height }\nreturn buildString {\nfor (item in sortedTransactions) {\nLog.i(TAG, \"Transaction list item: $item\")\nappendLine(\"Timestamp: ${item.confirmation.timestamp.timestampToString()}\")\nappendLine(\"Received: ${item.details.received}\")\nappendLine(\"Sent: ${item.details.sent}\")\nappendLine(\"Fees: ${item.details.fees}\")\nappendLine(\"Block: ${item.confirmation.height}\")\nappendLine(\"Txid: ${item.details.txid}\")\nappendLine()\n}\n}\n}\n}\n</code></pre> <p> </p> <p></p>"},{"location":"simple-wallet/#task-5-display-recovery-phrase","title":"Task 5: Display recovery phrase","text":"<p>Displaying the recovery phrase to the user is not a complicated task. Remember that we have stored the recovery phrase in shared preferences when creating the wallet <pre><code>fun createWallet(): Unit {\nval keys: ExtendedKeyInfo = generateExtendedKey(Network.TESTNET, WordCount.WORDS12, null)\nval descriptor: String = createDescriptor(keys)\nval changeDescriptor: String = createChangeDescriptor(keys)\ninitialize(\ndescriptor = descriptor,\nchangeDescriptor = changeDescriptor,\n)\nRepository.saveWallet(path, descriptor, changeDescriptor)\nRepository.saveMnemonic(keys.mnemonic)\n}\n</code></pre></p> <p>Retrieving the recovery phrase is a simple call to the repository, which has a <code>getMnemonic()</code> method defined: <pre><code>fun getMnemonic(): String {\nreturn sharedPreferencesManager.mnemonic\n}\n</code></pre></p> <p>Upon creating the screen, the <code>getMnemonic()</code> method is simply called to populate series of text composables: <pre><code>// RecoveryPhraseScreen.kt\n@Composable\ninternal fun RecoveryPhraseScreen(navController: NavController) {\nval seedPhrase: String = Repository.getMnemonic()\nval wordList: List&lt;String&gt; = seedPhrase.split(\" \")\nScaffold(\ntopBar = { AwayFromHomeAppBar(navController, \"Recovery Phrase\") },\n) {\nColumn(\nmodifier = Modifier\n.fillMaxSize()\n.padding(all = 32.dp)\n) {\nwordList.forEachIndexed { index, item -&gt;\nText(\ntext = \"${index + 1}. $item\",\nmodifier = Modifier.weight(weight = 1F),\ncolor = DevkitWalletColors.snow1,\nfontFamily = firaMono\n)\n}\n}\n}\n}\n</code></pre></p> <p> </p>"},{"location":"simple-wallet/#task-6-enable-wallet-recovery","title":"Task 6: Enable wallet recovery","text":"<p>Enabling wallet recovery is a matter of collecting a recovery phrase from the user and passing it to the bitcoindevkit, which will create our BIP32 root key from it.</p> <p>The Devkit Wallet does not to much input cleaning, and mostly implements the \"happy path\" for wallet recovery in the spirit of keeping the sample application lean and easy to parse. Once the \"Recover Wallet\" button is pressed, we pass the list of words collected from the <code>OutlinedTextField</code> composables through the <code>buildRecoveryPhrase()</code> function: <pre><code>// input words can have capital letters, space around them, space inside of them\nprivate fun buildRecoveryPhrase(recoveryPhraseWordMap: Map&lt;Int, String&gt;): String {\nvar recoveryPhrase = \"\"\nrecoveryPhraseWordMap.values.forEach() {\nrecoveryPhrase = recoveryPhrase.plus(it.trim().replace(\" \", \"\").lowercase().plus(\" \"))\n}\nreturn recoveryPhrase.trim()\n}\n</code></pre></p> <p>and give them to the Wallet object as a string. <pre><code>// Wallet.kt\nfun recoverWallet(mnemonic: String) {\nval keys: ExtendedKeyInfo = restoreExtendedKey(Network.TESTNET, mnemonic, null)\nval descriptor: String = createDescriptor(keys)\nval changeDescriptor: String = createChangeDescriptor(keys)\ninitialize(\ndescriptor = descriptor,\nchangeDescriptor = changeDescriptor,\n)\nRepository.saveWallet(path, descriptor, changeDescriptor)\nRepository.saveMnemonic(keys.mnemonic)\n}\n</code></pre></p> <p>Note the use of the <code>restoreExtendedKey()</code> method where the mnemonic is passed to the bitcoindevkit, returning a object of type <code>ExtendedKeyInfo</code>, which contains the BIP32 root key (<code>ExtendedKeyInfo.xprv</code>).</p> <p> </p>"},{"location":"ui/","title":"Building the UI","text":"<p>This page is the UI part of a walkthrough tutorial of the DevKit Wallet codebase.</p> <p>Note that this page concerns itself with the <code>ui</code> branch of the repository.</p> <p>The user interface for the Devkit Wallet is built using Jetpack Compose, the new, modern way to build user interfaces on Android. Going over the how Compose works is outside the scope of this documentation, but we'll point out the important parts that should help you understand how it all comes together on the UI side of things.</p> <p>Some of the important files and directories at this point are:</p>"},{"location":"ui/#1-the-buildgradlekts-files","title":"1. The <code>build.gradle.kts</code> files","text":"<p>Gradle is the build tool used by Android to describe the compilation steps for your app. The <code>build.gradle.kts</code> files use a Kotlin Domain Specific Language (DSL) to describe those steps, and some of the configuration options.</p>"},{"location":"ui/#2-files-in-the-appsrcmain-directory","title":"2. Files in the <code>app/src/main/</code> directory","text":"<p>The main directory breaks into two major parts: the Kotlin source code files and the resources files. The Kotlin source files define look and behavior on the application, whereas the resources are files are static things like strings, images, icons, etc.</p>"},{"location":"ui/#3-the-appsrcmainandroidmanifestxml-file","title":"3. The <code>app/src/main/AndroidManifest.xml</code> file","text":"<p>The Android Manifest file describes the activities that are registered for the app, the permissions that the app will requires (internet, camera, etc.), as well as some other metadata information necessary for the OS to start your application.</p> <p></p>"},{"location":"ui/#part-1-activity-and-navigation","title":"Part 1: Activity and Navigation","text":"<p>The Devkit Wallet is what is known as a single activity application. All screens are contained in this one activity (a low-level Android construct), and we navigate between the screens using a navigation component. Take a look at the <code>HomeNavigation</code> composable and notice how it allows you to navigate to 3 different screens: the <code>WalletScreen</code>, the <code>AboutScreen</code>, and the <code>RecoveryPhraseScreen</code>.</p> <p>The wallet is broken into 3 navigation graphs (<code>CreateWallet</code>, <code>Home</code>, and <code>Wallet</code>). Upon launch, the app will identify whether a wallet has already been created/loaded, and if not, fire up the <code>CreateWalletNavigation</code> graph (2 screens: create a new wallet and recover a existing wallet).</p> <p>      Your browser does not support the video tag.    <p></p> <p>If a wallet already exists on the device, the <code>HomeNavigation</code> graph is launched. This graph contains the home wallet screen with the drawer (containing the About and Recovery Phrase screens).</p> <p>      Your browser does not support the video tag.    <p></p> <p>The home wallet screen itself is simply a container for the <code>WalletNavigation</code> graph, which handles the core Home, Receive, Send, and Transactions screens.</p> <p>      Your browser does not support the video tag.    <p></p> <p>The screens themselves are built using what are known as composables, functions that build UI using the declarative paradigm for building user interfaces. You'll find them fairly intuitive at a glance; they mostly compose together a series of rows, columns, texts, buttons, and other common UI components into complete screens.</p>"}]}